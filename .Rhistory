detectCores()>1)
detectCores()>1
detectCores()
library(reshape2)
library(stringr)
library(ggplot2)
library(mgcv)
library(itsadug)
library(tidymv)
library(data.table)
library(zoo)
library(parallel)
detectCores()
## Mid Analysis
# Load Table
dfLong <- read.csv("Mid_GAMM.csv")
library(reshape2)
library(stringr)
library(ggplot2)
library(mgcv)
library(itsadug)
library(tidymv)
library(data.table)
library(zoo)
library(parallel)
## Mid Analysis
# Load Table
dfLong <- read.csv("Mid_GAMM.csv")
# Load necessary libraries
library("pracma")  # For mathematical functions like linspace
library("factoextra")  # For visualizing PCA results
## Loading required package: ggplot2
## Welcome! Want to learn more? See two factoextra-related books at https://goo.gl/ve3WBa
library("ggplot2")  # For plotting
# Create a sequence of values from 0 to 8*pi with 200 points
x = linspace(0, pi*8, n=200)
# Generate two cosine-based functions
y1 = cos(x)
y2 = 2 * cos(x * 2)
# Combine the data into a dataframe for ggplot
data = data.frame(x = rep(x, 2),
y = c(y1, y2),
functiona = factor(rep(c("y1", "y2"), each = 200)))
# Plot the functions with ggplot
ggplot(data, aes(x = x, y = y, color = functiona)) +
geom_line() +
labs(title = "Cosine Functions", x = "X", y = "Y") +
scale_color_manual(values = c("orange", "blue")) +
theme_bw()
# Load necessary libraries
library("pracma")  # For mathematical functions like linspace
installed.packages(c("pracma","factoextra","ggplot2"))
install.packages(c("pracma","factoextra","ggplot2"))
# Load necessary libraries
library("pracma")  # For mathematical functions like linspace
library("factoextra")  # For visualizing PCA results
## Loading required package: ggplot2
## Welcome! Want to learn more? See two factoextra-related books at https://goo.gl/ve3WBa
library("ggplot2")  # For plotting
# Create a sequence of values from 0 to 8*pi with 200 points
x = linspace(0, pi*8, n=200)
# Generate two cosine-based functions
y1 = cos(x)
y2 = 2 * cos(x * 2)
# Combine the data into a dataframe for ggplot
data = data.frame(x = rep(x, 2),
y = c(y1, y2),
functiona = factor(rep(c("y1", "y2"), each = 200)))
# Plot the functions with ggplot
ggplot(data, aes(x = x, y = y, color = functiona)) +
geom_line() +
labs(title = "Cosine Functions", x = "X", y = "Y") +
scale_color_manual(values = c("orange", "blue")) +
theme_bw()
Y = rbind(y1, y2)
# Perform PCA on the combined matrix Y
pc = prcomp(Y, retx = TRUE, center = TRUE, rank. = 3)
# Create a dataframe for the first principal component
pc_data = data.frame(index = 1:length(pc$rotation[, 1]),
PC1 = pc$rotation[, 1], mu = pc$center)
# Plot the first principal component with ggplot
ggplot(pc_data, aes(x = index, y = PC1 + mu)) +
geom_line(color = "black") +
labs(title = "First Principal Component", x = "Index", y = "PC1") +
theme_bw()
# Combine y1 and y2 into a matrix Y where each row is one function
Y = rbind(y1, y2)
# Perform PCA on the combined matrix Y
pc = prcomp(Y, retx = TRUE, center = TRUE, rank. = 3)
# Create a dataframe for the first principal component
pc_data = data.frame(index = 1:length(pc$rotation[, 1]),
PC1 = pc$rotation[, 1], mu = pc$center)
# Plot the first principal component with ggplot
ggplot(pc_data, aes(x = index, y = PC1 + mu)) +
geom_line(color = "black") +
labs(title = "First Principal Component", x = "Index", y = "PC1") +
theme_bw()
View(pc_data)
View(pc)
View(pc)
# Plot the first principal component with ggplot
ggplot(pc_data, aes(x = index, y = PC1) +
labs(title = "First Principal Component", x = "Index", y = "PC1") +
# Plot the first principal component with ggplot
ggplot(pc_data, aes(x = index, y = PC1+mu) +
labs(title = "First Principal Component", x = "Index", y = "PC1") +
# Plot the first principal component with ggplot
ggplot(pc_data, aes(x = index, y = PC1+mu) +
labs(title = "First Principal Component", x = "Index", y = "PC1") +
# Plot the first principal component with ggplot
ggplot(pc_data, aes(x = index, y = PC1+mu) +
labs(title = "First Principal Component", x = "Index", y = "PC1") +
# Load Libraries
library("tidyverse")
library("ggplot2")
library("ggdendro")
library("dendextend")
for (k in 1:3) {
# Assign the name based on the current iteration
name <- switch(k, "English40", "Thai42", "Vietnamese65")
dfName <- paste("results_Gandour_", name, ".rds", sep = "")
df <- readRDS(dfName)
# Create s1 and s2 by splitting the stimulus
df <- df %>%
mutate(s1 = map_chr(stimulus, ~ str_split(.x, "_")[[1]][2]),
s2 = map_chr(stimulus, ~ str_split(.x, "_")[[1]][3]))
# Filter out rows where the stimulus contains "check"
df <- df %>%
filter(!str_detect(stimulus, "check"))
# Create a unique, order-independent identifier for s1 and s2
df <- df %>%
mutate(pair_id = pmap_chr(list(s1, s2), ~ paste(sort(c(.x, .y)), collapse = "_")))
# Group by the unique identifier and calculate the mean response
dfSummary <- df %>%
group_by(pair_id) %>%
summarize(mean_response = mean(response, na.rm = TRUE)) %>%
ungroup()
# Extract the unique s1 and s2 values to create the matrix dimensions
unique_stimuli <- unique(c(df$s1, df$s2))
# Create an empty matrix with row and column names
response_matrix <- matrix(NA, nrow = length(unique_stimuli), ncol = length(unique_stimuli),
dimnames = list(unique_stimuli, unique_stimuli))
# Save the matrix with the filename "distanceM" followed by dfName
saveRDS(response_matrix, file = paste0("distanceM", dfName))
}
for (k in 1:3) {
# Assign the name based on the current iteration
name <- switch(k, "English40", "Thai42", "Vietnamese65")
dfName <- paste("results_Gandour_", name, ".rds", sep = "")
df <- readRDS(dfName)
# Create s1 and s2 by splitting the stimulus
df <- df %>%
mutate(s1 = map_chr(stimulus, ~ str_split(.x, "_")[[1]][2]),
s2 = map_chr(stimulus, ~ str_split(.x, "_")[[1]][3]))
# Filter out rows where the stimulus contains "check"
df <- df %>%
filter(!str_detect(stimulus, "check"))
# Create a unique, order-independent identifier for s1 and s2
df <- df %>%
mutate(pair_id = pmap_chr(list(s1, s2), ~ paste(sort(c(.x, .y)), collapse = "_")))
# Group by the unique identifier and calculate the mean response
dfSummary <- df %>%
group_by(pair_id) %>%
summarize(mean_response = mean(response, na.rm = TRUE)) %>%
ungroup()
# Extract the unique s1 and s2 values to create the matrix dimensions
unique_stimuli <- unique(c(df$s1, df$s2))
# Create an empty matrix with row and column names
response_matrix <- matrix(NA, nrow = length(unique_stimuli), ncol = length(unique_stimuli),
dimnames = list(unique_stimuli, unique_stimuli))
# Save the matrix with the filename "distanceM" followed by dfName
saveRDS(response_matrix, file = paste0("distanceM", dfName))
}
for (k in 1:3) {
# Assign the name based on the current iteration
name <- switch(k, "English40", "Thai42", "Vietnamese65")
dfName <- paste("results_Gandour_", name, ".rds", sep = "")
df <- readRDS(dfName)
# Create s1 and s2 by splitting the stimulus
df <- df %>%
mutate(s1 = map_chr(stimulus, ~ str_split(.x, "_")[[1]][2]),
s2 = map_chr(stimulus, ~ str_split(.x, "_")[[1]][3]))
# Filter out rows where the stimulus contains "check"
df <- df %>%
filter(!str_detect(stimulus, "check"))
# Create a unique, order-independent identifier for s1 and s2
df <- df %>%
mutate(pair_id = pmap_chr(list(s1, s2), ~ paste(sort(c(.x, .y)), collapse = "_")))
# Group by the unique identifier and calculate the mean response
dfSummary <- df %>%
group_by(pair_id) %>%
summarize(mean_response = mean(response, na.rm = TRUE)) %>%
ungroup()
# Extract the unique s1 and s2 values to create the matrix dimensions
unique_stimuli <- unique(c(df$s1, df$s2))
# Create an empty matrix with row and column names
response_matrix <- matrix(NA, nrow = length(unique_stimuli), ncol = length(unique_stimuli),
dimnames = list(unique_stimuli, unique_stimuli))
# Save the matrix with the filename "distanceM" followed by dfName
saveRDS(response_matrix, file = paste0("distanceM", dfName))
}
for (k in 1:3) {
# Assign the name based on the current iteration
name <- switch(k, "English40", "Thai42", "Vietnamese65")
dfName <- paste("results_Gandour_", name, ".rds", sep = "")
df <- readRDS(dfName)
# Create s1 and s2 by splitting the stimulus
df <- df %>%
mutate(s1 = map_chr(stimulus, ~ str_split(.x, "_")[[1]][2]),
s2 = map_chr(stimulus, ~ str_split(.x, "_")[[1]][3]))
# Filter out rows where the stimulus contains "check"
df <- df %>%
filter(!str_detect(stimulus, "check"))
# Create a unique, order-independent identifier for s1 and s2
df <- df %>%
mutate(pair_id = pmap_chr(list(s1, s2), ~ paste(sort(c(.x, .y)), collapse = "_")))
# Group by the unique identifier and calculate the mean response
dfSummary <- df %>%
group_by(pair_id) %>%
summarize(mean_response = mean(response, na.rm = TRUE)) %>%
ungroup()
# Extract the unique s1 and s2 values to create the matrix dimensions
unique_stimuli <- unique(c(df$s1, df$s2))
# Create an empty matrix with row and column names
response_matrix <- matrix(NA, nrow = length(unique_stimuli), ncol = length(unique_stimuli),
dimnames = list(unique_stimuli, unique_stimuli))
# Save the matrix with the filename "distanceM" followed by dfName
saveRDS(response_matrix, file = paste0("distanceM", dfName))
}
# Load Libraries
library("tidyverse")
library("ggplot2")
library("ggdendro")
library("dendextend")
for (k in 1:3) {
# Assign the name based on the current iteration
name <- switch(k, "English40", "Thai42", "Vietnamese65")
dfName <- paste("results_Gandour_", name, ".rds", sep = "")
df <- readRDS(dfName)
# Create s1 and s2 by splitting the stimulus
df <- df %>%
mutate(s1 = map_chr(stimulus, ~ str_split(.x, "_")[[1]][2]),
s2 = map_chr(stimulus, ~ str_split(.x, "_")[[1]][3]))
# Filter out rows where the stimulus contains "check"
df <- df %>%
filter(!str_detect(stimulus, "check"))
# Create a unique, order-independent identifier for s1 and s2
df <- df %>%
mutate(pair_id = pmap_chr(list(s1, s2), ~ paste(sort(c(.x, .y)), collapse = "_")))
# Group by the unique identifier and calculate the mean response
dfSummary <- df %>%
group_by(pair_id) %>%
summarize(mean_response = mean(response, na.rm = TRUE)) %>%
ungroup()
# Extract the unique s1 and s2 values to create the matrix dimensions
unique_stimuli <- unique(c(df$s1, df$s2))
# Create an empty matrix with row and column names
response_matrix <- matrix(NA, nrow = length(unique_stimuli), ncol = length(unique_stimuli),
dimnames = list(unique_stimuli, unique_stimuli))
# Save the matrix with the filename "distanceM" followed by dfName
saveRDS(response_matrix, file = paste0("distanceM", dfName))
}
source("~/Library/Mobile Documents/com~apple~CloudDocs/Projects/TonePerception/preProcess.R", echo=TRUE)
df <- read.csv(paste(getwd(),"/Tables/TableIntragestural.csv",sep = ""))
df$SP <- as.factor((df$SP))
df$Gem <- as.factor((df$Gem))
df$Segment <- as.factor(df$Segment)
library(brms)
df <- read.csv(paste(getwd(),"/Tables/TableIntragestural.csv",sep = ""))
setwd("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/GitHub/MutualInformation")
source("getMI.R")
MI_nats <- getMI(x, y, nBins=20, smoothingValue = 0.5, units = "nats")
MI_bits <- getMI(x, y, nBins=20, smoothingValue = 0.5, units = "bits")
cat(sprintf("Mutual Information: %.4f nats\n", MI_nats))
cat(sprintf("Mutual Information: %.4f bits\n", MI_bits))
# Example of pre-generated uncorrelated (x1,y1) and correlated variables (x2,y2)
x1 <- as.vector(read.csv("x1.csv",header = FALSE))
y1 <- as.vector(read.csv("y1.csv",header = FALSE))
x2 <- as.vector(read.csv("x2.csv",header = FALSE))
y2 <- as.vector(read.csv("y2.csv",header = FALSE))
source("getMI.R")
MI1 <- getMI(unlist(x1),unlist(y1), nBins=20, smoothingValue = 0.5, units = "bits")
MI2 <- getMI(unlist(x2),unlist(y2),nBins=20, smoothingValue = 0.5, units = "bits")
cat(sprintf("MI of x1 and y1 is  %.3f bits\n", MI1))
cat(sprintf("MI of x2 and y2 is %.3f bits\n", MI2))
# Example of pre-generated uncorrelated (x1,y1) and correlated variables (x2,y2)
x1 <- as.vector(read.csv("x1.csv",header = FALSE))
y1 <- as.vector(read.csv("y1.csv",header = FALSE))
x2 <- as.vector(read.csv("x2.csv",header = FALSE))
y2 <- as.vector(read.csv("y2.csv",header = FALSE))
source("getMI.R")
MI1 <- getMI(unlist(x1),unlist(y1), nBins=20, smoothingValue = 0.5, units = "bits")
MI2 <- getMI(unlist(x2),unlist(y2),nBins=20, smoothingValue = 0.5, units = "bits")
cat(sprintf("MI of x1 and y1 is  %.3f bits\n", MI1))
cat(sprintf("MI of x2 and y2 is %.3f bits\n", MI2))
summary(x2)
summary(y2)
range(x2); range(y2)
quantile(y2, c(.001, .01, .5, .99, .999), na.rm=TRUE)
histogram(X1)
# Example of pre-generated uncorrelated (x1,y1) and correlated variables (x2,y2)
x1 <- as.vector(read.csv("x1.csv",header = FALSE))
y1 <- as.vector(read.csv("y1.csv",header = FALSE))
x2 <- as.vector(read.csv("x2.csv",header = FALSE))
y2 <- as.vector(read.csv("y2.csv",header = FALSE))
source("getMI.R")
MI1 <- getMI(unlist(x1),unlist(y1), nBins=20, smoothingValue = 0.5, units = "bits")
MI2 <- getMI(unlist(x2),unlist(y2),nBins=20, smoothingValue = 0.5, units = "bits")
cat(sprintf("MI of x1 and y1 is  %.3f bits\n", MI1))
cat(sprintf("MI of x2 and y2 is %.3f bits\n", MI2))
source("getMI.R")
MI1 <- getMI(unlist(x1),unlist(y1), nBins=20, smoothingValue = 0.5, units = "bits")
# Example usage:
set.seed(1310)
x <- rnorm(1000)
y <- rnorm(1000)
source("getMI.R")
MI_nats <- getMI(x, y, nBins=20, smoothingValue = 0.5, units = "nats")
MI_bits <- getMI(x, y, nBins=20, smoothingValue = 0.5, units = "bits")
cat(sprintf("Mutual Information: %.4f nats\n", MI_nats))
cat(sprintf("Mutual Information: %.4f bits\n", MI_bits))
# Example of pre-generated uncorrelated (x1,y1) and correlated variables (x2,y2)
x1 <- as.vector(read.csv("x1.csv",header = FALSE))
y1 <- as.vector(read.csv("y1.csv",header = FALSE))
x2 <- as.vector(read.csv("x2.csv",header = FALSE))
y2 <- as.vector(read.csv("y2.csv",header = FALSE))
source("getMI.R")
MI1 <- getMI(unlist(x1),unlist(y1), nBins=20, smoothingValue = 0.5, units = "bits")
MI2 <- getMI(unlist(x2),unlist(y2),nBins=20, smoothingValue = 0.5, units = "bits")
cat(sprintf("MI of x1 and y1 is  %.3f bits\n", MI1))
cat(sprintf("MI of x2 and y2 is %.3f bits\n", MI2))
# Example usage:
set.seed(1310)
x <- rnorm(1000)
y <- rnorm(1000)
source("getMI.R")
MI_nats <- getMI(x, y, nBins=20, smoothingValue = 0.5, units = "nats")
MI_bits <- getMI(x, y, nBins=20, smoothingValue = 0.5, units = "bits")
cat(sprintf("Mutual Information: %.4f nats\n", MI_nats))
cat(sprintf("Mutual Information: %.4f bits\n", MI_bits))
# Example of pre-generated uncorrelated (x1,y1) and correlated variables (x2,y2)
x1 <- as.vector(read.csv("x1.csv",header = FALSE))
y1 <- as.vector(read.csv("y1.csv",header = FALSE))
x2 <- as.vector(read.csv("x2.csv",header = FALSE))
y2 <- as.vector(read.csv("y2.csv",header = FALSE))
source("getMI.R")
MI1 <- getMI(unlist(x1),unlist(y1), nBins=20, smoothingValue = 0.5, units = "bits")
MI2 <- getMI(unlist(x2),unlist(y2),nBins=20, smoothingValue = 0.5, units = "bits")
cat(sprintf("MI of x1 and y1 is  %.3f bits\n", MI1))
cat(sprintf("MI of x2 and y2 is %.3f bits\n", MI2))
# Example usage:
set.seed(1310)
x <- rnorm(1000)
y <- rnorm(1000)
source("getMI.R")
MI_nats <- getMI(x, y, nBins=20, smoothingValue = 0.5, units = "nats")
MI_bits <- getMI(x, y, nBins=20, smoothingValue = 0.5, units = "bits")
cat(sprintf("Mutual Information: %.4f nats\n", MI_nats))
cat(sprintf("Mutual Information: %.4f bits\n", MI_bits))
# Example of pre-generated uncorrelated (x1,y1) and correlated variables (x2,y2)
x1 <- as.vector(read.csv("x1.csv",header = FALSE))
y1 <- as.vector(read.csv("y1.csv",header = FALSE))
x2 <- as.vector(read.csv("x2.csv",header = FALSE))
y2 <- as.vector(read.csv("y2.csv",header = FALSE))
source("getMI.R")
MI1 <- getMI(unlist(x1),unlist(y1), nBins=20, smoothingValue = 0.5, units = "bits")
MI2 <- getMI(unlist(x2),unlist(y2),nBins=20, smoothingValue = 0.5, units = "bits")
cat(sprintf("MI of x1 and y1 is  %.3f bits\n", MI1))
cat(sprintf("MI of x2 and y2 is %.3f bits\n", MI2))
